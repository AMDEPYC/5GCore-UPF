From ba889ec243d3c95ef5511990be1bc9145f5dd3f6 Mon Sep 17 00:00:00 2001
From: Sivaprasad Tummala <sivaprasad.tummala@amd.com>
Date: Thu, 27 Nov 2025 10:23:05 +0000
Subject: [PATCH 2/2] upf: prevent flow expiration by non-owner threads

This patch adds a thread-ownership check to try_expire_single_flow()
to ensure that only the thread that created a flow is allowed to
expire and delete it.

Each flow stores the CPU index of the thread that created it
(f->cpu_index). Previously, any worker thread processing a timer
bucket could attempt to expire flows, which could lead to cross-thread
races, inconsistent state updates, or premature deletion.

Signed-off-by: Sivaprasad Tummala <sivaprasad.tummala@amd.com>
---
 upf/flowtable.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/upf/flowtable.c b/upf/flowtable.c
index 34a5042..691bdc2 100644
--- a/upf/flowtable.c
+++ b/upf/flowtable.c
@@ -91,12 +91,21 @@ try_expire_single_flow (flowtable_main_t *fm, flowtable_main_per_cpu_t *fmt,
   bool keep = f->active + f->lifetime > now;
   ASSERT (f->timer_slot == (e - fmt->timers));
   ASSERT (f->active <= now);
+  u32 current_thread = os_get_thread_index();
 
   upf_debug ("Flow Timeout Check %d: %u (%u) > %u (%u)", f - fm->flows,
              f->active + f->lifetime,
              (f->active + f->lifetime) % FLOW_TIMER_MAX_LIFETIME, now,
              fmt->time_index);
 
+  /* Prevent non-owner threads from expiring this flow */
+  if (f->cpu_index != current_thread)
+    {
+        upf_debug("Flow %d: expiration skipped (owned by thread %u, current %u)",
+                  f - fm->flows, f->cpu_index, current_thread);
+        keep = true;
+    }
+
   if (!keep && upf_proxy_flow_expire_event_handler (f))
     {
       /* flow still in use, wait for another lifetime */
-- 
2.34.1

